<!DOCTYPE html> <html lang="fr"> <head itemscope itemtype="http://schema.org/WebSite"> <meta charset="utf-8"> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <title>Développement CSS3 compatible multi-navigateurs avec Modernizr et eCSStender | bertrandkeller</title> <meta property="og:title" content="Développement CSS3 compatible multi-navigateurs avec Modernizr et eCSStender"/> <meta property="og:locale" content="fr"/> <meta name="description" content="Que des soucis c&#39;est nouvelles règles CSS3. On s&#39;extasie devant la possibilité d&#39;intégrer quelques coins arrondis sur Firefox, Webkit et Opéra et dès qu&#39;on exploite un peu le filon, on se rend compte que les techniques d&#39;exploitation se multiplient. On peut choisir de ne pas utiliser de règles CSS3, d&#39;en exploiter certaines ou encore de se servir de toutes mais de ne pas prendre en compte l&#39;ensemble de navigateurs. En effet, les propriétés ne sont pas encore tout à fait implémentées dans les navigateurs et chacun utilise ce qu&#39;on nomme des préfixes pour les produire : -webkit-border-radius: 12px; -moz-border-radius: 12px; border-radius: 12px; Le problème fondamental reste garantir un code compatible dans le temps (1 an, 2 ans, 5 ans...). Comment écrire un code simple, court, lisible, facilement modifiable et compatible au court du temps avec les avancées probables des navigateurs ? Modernizr La première solution est d&#39;utiliser Modernizr. Ce script teste la compatibilité du navigateur de l&#39;utilisateur avec les règles CSS3 ou autres. En fonction des capacités du navigateur, le script ajoute un préfixe (no-) sur la classe appliquée dans le code CSS. Ainsi, on déclare dans un sélecteur le code pour les navigateurs qui supportent une propriété, on déclare dans un autre sélecteur le code préfixe (avec le préfixe no-) pour les navigateurs qui ne supporte pas la propriété. Sans appeler de feuilles particulières, Modernizr va modifier le code de la page en HTML pour que le style adapté aux capacités du navigateur s&#39;affiche. Enorme avantage de ne pas cibler un navigateur mais bien une propriété en particulier, avec son alternative. Lire Taking Advantage of HTML5 and CSS3 with Modernizr. eCSStender Autre couche JavaScript sur l&#39;interprétation des feuilles de style, eCSStender script qui permet de ne plus jongler les propriétés préfixées par moteur de rendu (-moz, -webkit, -o, -khtml...). Souvent le travailleur du web imagine les utilisateurs comme lui, souvent exactement comme lui : un mac avec Safari et Firefox. Sauf que les moteurs de rendus ne sont pas au nombre de 2 mais sont plus diversifiées que ça. Donc quand on déclare une propriété comme : -webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;. On est très content, c&#39;est beau, sauf que quand on nous demande de l&#39;appliquer à l&#39;ensemble des navigateurs, ça peut devenir : border-radius: 10px 5px;-moz-border-radius: 10px 5px;-webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;-o-border-radius: 10px 5px;-khtml-border-top-left-radius: 10px;-khtml-border-top-right-radius: 5px;-khtml-border-bottom-right-radius: 10px;-khtml-border-bottom-left-radius: 5px; Appliquer des petits coins arrondis demandent donc d&#39;appliquer des hacks spécifiques à chaque navigateur. Cette façon de procéder allonge le code mais augmente, de même, le nombre d&#39;erreurs possibles. Script eCSStender vient à mon aide. On disait que quand j&#39;écrivais une propriété du type : border-radius: 5px; ; toi tu t&#39;arrangeais pour sortir au navigateur ce qu&#39;il comprend ; le machin avec les préfixes. Comme ça moi, j&#39;écris du CSS3 de manière idéale, mon code est propre, court et en plus si jamais, un jour, un nouveau moteur sort avec son préfixe à lui, j&#39;ai juste à mettre à jour mon fichier .js. Lire Stop Forking with CSS3. Conclusion Certes Modernizr et eCSStender sont deux scripts JavaScript, leur utilisation augmente le poids de la page à télécharger. Cependant, leur utilisation permet, d&#39;une part, d&#39;écrire un code spécifique (dégradé) pour les navigateurs qui n&#39;ont pas implémentés certaines propriétés et, d&#39;autre part, de ne plus surcharger son code avec des spécificités particulières à chaque navigateur."/> <meta property="og:description" content="Que des soucis c&#39;est nouvelles règles CSS3. On s&#39;extasie devant la possibilité d&#39;intégrer quelques coins arrondis sur Firefox, Webkit et Opéra et dès qu&#39;on exploite un peu le filon, on se rend compte que les techniques d&#39;exploitation se multiplient. On peut choisir de ne pas utiliser de règles CSS3, d&#39;en exploiter certaines ou encore de se servir de toutes mais de ne pas prendre en compte l&#39;ensemble de navigateurs. En effet, les propriétés ne sont pas encore tout à fait implémentées dans les navigateurs et chacun utilise ce qu&#39;on nomme des préfixes pour les produire : -webkit-border-radius: 12px; -moz-border-radius: 12px; border-radius: 12px; Le problème fondamental reste garantir un code compatible dans le temps (1 an, 2 ans, 5 ans...). Comment écrire un code simple, court, lisible, facilement modifiable et compatible au court du temps avec les avancées probables des navigateurs ? Modernizr La première solution est d&#39;utiliser Modernizr. Ce script teste la compatibilité du navigateur de l&#39;utilisateur avec les règles CSS3 ou autres. En fonction des capacités du navigateur, le script ajoute un préfixe (no-) sur la classe appliquée dans le code CSS. Ainsi, on déclare dans un sélecteur le code pour les navigateurs qui supportent une propriété, on déclare dans un autre sélecteur le code préfixe (avec le préfixe no-) pour les navigateurs qui ne supporte pas la propriété. Sans appeler de feuilles particulières, Modernizr va modifier le code de la page en HTML pour que le style adapté aux capacités du navigateur s&#39;affiche. Enorme avantage de ne pas cibler un navigateur mais bien une propriété en particulier, avec son alternative. Lire Taking Advantage of HTML5 and CSS3 with Modernizr. eCSStender Autre couche JavaScript sur l&#39;interprétation des feuilles de style, eCSStender script qui permet de ne plus jongler les propriétés préfixées par moteur de rendu (-moz, -webkit, -o, -khtml...). Souvent le travailleur du web imagine les utilisateurs comme lui, souvent exactement comme lui : un mac avec Safari et Firefox. Sauf que les moteurs de rendus ne sont pas au nombre de 2 mais sont plus diversifiées que ça. Donc quand on déclare une propriété comme : -webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;. On est très content, c&#39;est beau, sauf que quand on nous demande de l&#39;appliquer à l&#39;ensemble des navigateurs, ça peut devenir : border-radius: 10px 5px;-moz-border-radius: 10px 5px;-webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;-o-border-radius: 10px 5px;-khtml-border-top-left-radius: 10px;-khtml-border-top-right-radius: 5px;-khtml-border-bottom-right-radius: 10px;-khtml-border-bottom-left-radius: 5px; Appliquer des petits coins arrondis demandent donc d&#39;appliquer des hacks spécifiques à chaque navigateur. Cette façon de procéder allonge le code mais augmente, de même, le nombre d&#39;erreurs possibles. Script eCSStender vient à mon aide. On disait que quand j&#39;écrivais une propriété du type : border-radius: 5px; ; toi tu t&#39;arrangeais pour sortir au navigateur ce qu&#39;il comprend ; le machin avec les préfixes. Comme ça moi, j&#39;écris du CSS3 de manière idéale, mon code est propre, court et en plus si jamais, un jour, un nouveau moteur sort avec son préfixe à lui, j&#39;ai juste à mettre à jour mon fichier .js. Lire Stop Forking with CSS3. Conclusion Certes Modernizr et eCSStender sont deux scripts JavaScript, leur utilisation augmente le poids de la page à télécharger. Cependant, leur utilisation permet, d&#39;une part, d&#39;écrire un code spécifique (dégradé) pour les navigateurs qui n&#39;ont pas implémentés certaines propriétés et, d&#39;autre part, de ne plus surcharger son code avec des spécificités particulières à chaque navigateur."/> <link rel="canonical" href="https://bertrandkeller.info/2010/07/05/developpement-css3-compatible-multi-navigateurs-avec-modernizr-et-ecsstender/"/> <meta property="og:url" content="https://bertrandkeller.info/2010/07/05/developpement-css3-compatible-multi-navigateurs-avec-modernizr-et-ecsstender/"/> <meta property="og:site_name" content="bertrandkeller"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2010-07-05T12:29:38+02:00"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:site" content="@bertrandkeller"/> <script type="application/ld+json">
{"name":null,"description":"Que des soucis c&#39;est nouvelles règles CSS3. On s&#39;extasie devant la possibilité d&#39;intégrer quelques coins arrondis sur Firefox, Webkit et Opéra et dès qu&#39;on exploite un peu le filon, on se rend compte que les techniques d&#39;exploitation se multiplient. On peut choisir de ne pas utiliser de règles CSS3, d&#39;en exploiter certaines ou encore de se servir de toutes mais de ne pas prendre en compte l&#39;ensemble de navigateurs. En effet, les propriétés ne sont pas encore tout à fait implémentées dans les navigateurs et chacun utilise ce qu&#39;on nomme des préfixes pour les produire : -webkit-border-radius: 12px; -moz-border-radius: 12px; border-radius: 12px; Le problème fondamental reste garantir un code compatible dans le temps (1 an, 2 ans, 5 ans...). Comment écrire un code simple, court, lisible, facilement modifiable et compatible au court du temps avec les avancées probables des navigateurs ? Modernizr La première solution est d&#39;utiliser Modernizr. Ce script teste la compatibilité du navigateur de l&#39;utilisateur avec les règles CSS3 ou autres. En fonction des capacités du navigateur, le script ajoute un préfixe (no-) sur la classe appliquée dans le code CSS. Ainsi, on déclare dans un sélecteur le code pour les navigateurs qui supportent une propriété, on déclare dans un autre sélecteur le code préfixe (avec le préfixe no-) pour les navigateurs qui ne supporte pas la propriété. Sans appeler de feuilles particulières, Modernizr va modifier le code de la page en HTML pour que le style adapté aux capacités du navigateur s&#39;affiche. Enorme avantage de ne pas cibler un navigateur mais bien une propriété en particulier, avec son alternative. Lire Taking Advantage of HTML5 and CSS3 with Modernizr. eCSStender Autre couche JavaScript sur l&#39;interprétation des feuilles de style, eCSStender script qui permet de ne plus jongler les propriétés préfixées par moteur de rendu (-moz, -webkit, -o, -khtml...). Souvent le travailleur du web imagine les utilisateurs comme lui, souvent exactement comme lui : un mac avec Safari et Firefox. Sauf que les moteurs de rendus ne sont pas au nombre de 2 mais sont plus diversifiées que ça. Donc quand on déclare une propriété comme : -webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;. On est très content, c&#39;est beau, sauf que quand on nous demande de l&#39;appliquer à l&#39;ensemble des navigateurs, ça peut devenir : border-radius: 10px 5px;-moz-border-radius: 10px 5px;-webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;-o-border-radius: 10px 5px;-khtml-border-top-left-radius: 10px;-khtml-border-top-right-radius: 5px;-khtml-border-bottom-right-radius: 10px;-khtml-border-bottom-left-radius: 5px; Appliquer des petits coins arrondis demandent donc d&#39;appliquer des hacks spécifiques à chaque navigateur. Cette façon de procéder allonge le code mais augmente, de même, le nombre d&#39;erreurs possibles. Script eCSStender vient à mon aide. On disait que quand j&#39;écrivais une propriété du type : border-radius: 5px; ; toi tu t&#39;arrangeais pour sortir au navigateur ce qu&#39;il comprend ; le machin avec les préfixes. Comme ça moi, j&#39;écris du CSS3 de manière idéale, mon code est propre, court et en plus si jamais, un jour, un nouveau moteur sort avec son préfixe à lui, j&#39;ai juste à mettre à jour mon fichier .js. Lire Stop Forking with CSS3. Conclusion Certes Modernizr et eCSStender sont deux scripts JavaScript, leur utilisation augmente le poids de la page à télécharger. Cependant, leur utilisation permet, d&#39;une part, d&#39;écrire un code spécifique (dégradé) pour les navigateurs qui n&#39;ont pas implémentés certaines propriétés et, d&#39;autre part, de ne plus surcharger son code avec des spécificités particulières à chaque navigateur.","author":null,"@type":"BlogPosting","url":"https://bertrandkeller.info/2010/07/05/developpement-css3-compatible-multi-navigateurs-avec-modernizr-et-ecsstender/","image":null,"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://bertrandkeller.info/assets/bertrandkeller.png"}},"headline":"Développement CSS3 compatible multi-navigateurs avec Modernizr et eCSStender","dateModified":"2010-07-05T12:29:38+02:00","datePublished":"2010-07-05T12:29:38+02:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://bertrandkeller.info/2010/07/05/developpement-css3-compatible-multi-navigateurs-avec-modernizr-et-ecsstender/"},"@context":"http://schema.org"}</script> <meta property="og:type" content="post"/> <meta name="subject" content="Histoire de gestion de contenu, générateur de site statique et autres"> <meta name="generator" content="jekyll v3.6.2"> <meta itemprop="name" content="Développement CSS3 compatible multi-navigateurs avec Modernizr et eCSStender | bertrandkeller"> <meta itemprop="description" content="Histoire de gestion de contenu, générateur de site statique et autres"> <meta itemprop="image" content="/assets/bertrandkeller.png"> <meta name="robots" content=""> <link rel="preload" href="/assets/css/font.css" as="stylesheet"> <link href="/assets/css/main.css" rel="stylesheet"> <script data-no-instant>
    !function(){"use strict";function e(e,t,n){e.addEventListener?e.addEventListener(t,n,!1):e.attachEvent&&e.attachEvent("on"+t,n)}function t(e){return window.localStorage&&localStorage.font_css_cache&&localStorage.font_css_cache_file===e}function n(){if(window.localStorage&&window.XMLHttpRequest)if(t(o))c(localStorage.font_css_cache);else{var n=new XMLHttpRequest;n.open("GET",o,!0),e(n,"load",function(){4===n.readyState&&(c(n.responseText),localStorage.font_css_cache=n.responseText,localStorage.font_css_cache_file=o)}),n.send()}else{var a=document.createElement("link");a.href=o,a.rel="stylesheet",a.type="text/css",document.getElementsByTagName("head")[0].appendChild(a),document.cookie="font_css_cache";}}function c(e){var t=document.createElement("style");t.innerHTML=e,document.getElementsByTagName("head")[0].appendChild(t),document.getElementsByTagName("html")[0].className+=' font-loaded'}var o="/assets/css/font.css";window.localStorage&&localStorage.font_css_cache||document.cookie.indexOf("font_css_cache")>-1?n():e(window,"load",n)}();

  </script> <link href="/humans.txt" rel="author" type="text/plain"/> <link href="https://bertrandkeller.info/feed/" rel="alternate" type="application/rss+xml" title="bertrandkeller RSS Feed"/> <meta name="google-site-verification" content="TLPgjqS26dGLPiEz9QUF3u5uaTQnvQRAc3HoaRvC_S8"/> <link rel="preload" href="/favicon.ico" as="image"> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png"> <link rel="manifest" href="/manifest.json"> <link rel="mask-icon" href="/assets/favicons//safari-pinned-tab.svg" color="#5bbad5"> <meta name="theme-color" content="#000000"> <meta name="msapplication-config" content="/browserconfig.xml"> </head> <body class="page" itemscope itemtype="http://schema.org/WebPage"> <div class="skip-links"> <a href="#main">Contenu principal</a> </div> <header class="site-header" role="banner"> <div class="site-header-top site-header-top__align wrapper"> <p class="site-logo"> <a class="site-title" href="/">bertrandkeller</a> </p> <nav class="nav-main nav-main__scroll" role="navigation"> <ul> <li><a class="page-link" href="/archives/">Archives</a></li> <li><a class="page-link" href="/conseil-prestation-formation/">Prestations</a></li> <li><a class="page-link" href="/site-internet-conference/">Portfolio</a></li> </ul> </nav> </div> </header> <main id="main" role="main"> <div class="wrapper"> <article class="post"> <h1 class="post-title">Développement CSS3 compatible multi-navigateurs avec Modernizr et eCSStender</h1> <p class="post-meta">05/07/2010</p> <p>Que des soucis c'est nouvelles règles CSS3. On s'extasie devant la possibilité d'intégrer quelques coins arrondis sur Firefox, Webkit et Opéra et dès qu'on exploite un peu le filon, on se rend compte que les techniques d'exploitation se multiplient.</p> <p>On peut choisir de ne pas utiliser de règles CSS3, d'en exploiter certaines ou encore de se servir de toutes mais de ne pas prendre en compte l'ensemble de navigateurs. En effet, les propriétés ne sont pas encore tout à fait implémentées dans les navigateurs et chacun utilise ce qu'on nomme des préfixes pour les produire : <strong>-webkit-border-radius: 12px; -moz-border-radius: 12px; border-radius: 12px;</strong></p> <div class="center"><a href="http://static.bertrandkeller.info/2010/07/ALA308_eCSStender_final.jpg"><img src="/assets/ALA308_eCSStender_final.jpg" alt="" title="A list apart" width="540" height="216" class="aligncenter size-full wp-image-2506"/></a></div> <p>Le problème fondamental reste garantir un code compatible dans le temps (1 an, 2 ans, 5 ans...). Comment écrire un code simple, court, lisible, facilement modifiable et compatible au court du temps avec les avancées probables des navigateurs ?</p> <h3>Modernizr</h3> <p>La première solution est d'utiliser Modernizr. Ce script teste la compatibilité du navigateur de l'utilisateur avec les règles CSS3 ou autres. En fonction des capacités du navigateur, le script ajoute un préfixe (no-) sur la classe appliquée dans le code CSS.</p> <p>Ainsi, on déclare dans un sélecteur le code pour les navigateurs qui supportent une propriété, on déclare dans un autre sélecteur le code préfixe (avec le préfixe no-) pour les navigateurs qui ne supporte pas la propriété.</p> <p>Sans appeler de feuilles particulières, Modernizr va modifier le code de la page en HTML pour que le style adapté aux capacités du navigateur s'affiche.</p> <p>Enorme avantage de ne pas cibler un navigateur mais bien une propriété en particulier, avec son alternative.</p> <p>Lire <a href="http://www.alistapart.com/articles/taking-advantage-of-html5-and-css3-with-modernizr/" title="Taking Advantage of HTML5 and CSS3 with Modernizr">Taking Advantage of HTML5 and CSS3 with Modernizr</a>.</p> <h3>eCSStender</h3> <p>Autre couche JavaScript sur l'interprétation des feuilles de style, eCSStender script qui permet de ne plus jongler les propriétés préfixées par moteur de rendu (-moz, -webkit, -o, -khtml...).</p> <p>Souvent le travailleur du web imagine les utilisateurs comme lui, souvent exactement comme lui : un mac avec Safari et Firefox. Sauf que les moteurs de rendus ne sont pas au nombre de 2 mais sont plus diversifiées que ça.</p> <p>Donc quand on déclare une propriété comme : <strong>-webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;</strong>.</p> <p>On est très content, c'est beau, sauf que quand on nous demande de l'appliquer à l'ensemble des navigateurs, ça peut devenir : <strong>border-radius: 10px 5px;-moz-border-radius: 10px 5px;-webkit-border-top-left-radius: 10px;-webkit-border-top-right-radius: 5px;-webkit-border-bottom-right-radius: 10px;-webkit-border-bottom-left-radius: 5px;-o-border-radius: 10px 5px;-khtml-border-top-left-radius: 10px;-khtml-border-top-right-radius: 5px;-khtml-border-bottom-right-radius: 10px;-khtml-border-bottom-left-radius: 5px;</strong></p> <p>Appliquer des petits coins arrondis demandent donc d'appliquer des hacks spécifiques à chaque navigateur. Cette façon de procéder allonge le code mais augmente, de même, le nombre d'erreurs possibles.</p> <p>Script eCSStender vient à mon aide. On disait que quand j'écrivais une propriété du type : <strong>border-radius: 5px;</strong> ; toi tu t'arrangeais pour sortir au navigateur ce qu'il comprend ; le machin avec les préfixes.</p> <p>Comme ça moi, j'écris du CSS3 de manière idéale, mon code est propre, court et en plus si jamais, un jour, un nouveau moteur sort avec son préfixe à lui, j'ai juste à mettre à jour mon fichier .js.</p> <p>Lire <a href="http://www.alistapart.com/articles/stop-forking-with-css3/" title="Stop Forking with CSS3">Stop Forking with CSS3</a>.</p> <h3>Conclusion</h3> <p>Certes Modernizr et eCSStender sont deux scripts JavaScript, leur utilisation augmente le poids de la page à télécharger. Cependant, leur utilisation permet, d'une part, d'écrire un code spécifique (dégradé) pour les navigateurs qui n'ont pas implémentés certaines propriétés et, d'autre part, de ne plus surcharger son code avec des spécificités particulières à chaque navigateur.</p> </article> <nav class="pagination--prevnext" role="navigation"> <div class="pagination--prev"> <a class="pagination--item" href="/2010/07/01/nicolle-sullivan-pour-les-performances-css-au-velocity-2010/"> Nicolle Sullivan pour les performances CSS au Velocity 2010 </a> </div> <div class="pagination--next"> <a class="pagination--item" href="/2010/07/06/big-bag-big-boom-par-blu/"> BIG BAG BIG BOOM par BLU </a> </div> </nav> </div> </main> <script src="https://bertrandkeller.info/assets/js/fetch-inject.js"></script> <script>
    fetchInject([
      'https://bertrandkeller.info/assets/js/instantclick.min.js'
    ]).then(() => {
        InstantClick.init();
      })
    </script> <script data-no-instant>
		if (navigator.serviceWorker) {
			navigator.serviceWorker.register('/sw.js', {
					scope: '/'
			});
			window.addEventListener('load', function() {
					if (navigator.serviceWorker.controller) {
							navigator.serviceWorker.controller.postMessage({'command': 'trimCaches'});
					}
			});
		}
</script> </body> </html>